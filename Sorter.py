print('''
Python3-скрипт, сортирующий таблицу по указанным пользователем столбцам.
Автор: Платон Быкадоров (platon.work@gmail.com), 2018.
Версия: V2.
Лицензия: GNU General Public License version 3.
Поддержать проект: https://money.yandex.ru/to/41001832285976

В скрипте реализован алгоритм получения наиболее универсальных правил сортировки.
Этот алгоритм создаёт правила, согласно которым сортировка ведётся по символам,
способным и, наоборот, неспособным принимать числовой тип данных.

Для конкретно вашей задачи могут потребоваться специфические правила сортировки.
В таком случае пишите в Issues, и я постараюсь создать
версию программы-сортировщика с персонализированными хаками.
''')

def cell_split(cell, sort_rule, cur_start_index = 0):
        '''
        Чтобы отделить друг от друга символы, способные
        быть представленными как вещественное число, от
        символов, могущих пренадлежать лишь строковому типу
        данных, функция обрабатывает ячейку отрезками.
        Отрезок должен включать в себя, как минимум, одно число
        или одну строку, а, как максимум, и строку, и число.
        Отделённые друг от друга на основании типа
        данных части ячейки поступят в список-"правило".
        Правилами такие списки назовём, т.к. из них
        будет составляться ключ сортировки таблицы,
        и, соответственно, они будут определять,
        каким образом таблица будет отсортирована.
        '''

        #Поиск числа в очередном отрезке строки.
        #Результат - либо None, либо представляет собой
        #объект, содержащий найденное число, а также
        #индексы его начала и конца в этом отрезке.
        #Далее эти индексы пригодятся для определения границ
        #как между строковой и численной составляющих текущего
        #отрезка, так и между текущим и следующим отрезками.
        num_object = re.search(r'-\d+\.\d+|\d+\.\d+|-\d+|\d+', cell[cur_start_index:])

        #Число нашлось.
        if num_object != None:

                #Число могло найтись как целое, так и дробное.
                #Чтобы найденные числа правильно сравнивались при
                #дальнейшей сортировке, конвертируем их все в вещественные.
                num_value = float(num_object.group())

                #Чтобы отмерить текущие индексы начала и конца найденного числа
                #относительно начала всей ячейки, соответствующие индексы, сосчитанные
                #внутри отрезка ячейки, прибавляются к текущему индексу начала отрезка.
                num_min_index = cur_start_index + num_object.span()[0]
                num_max_index = cur_start_index + num_object.span()[1]

                #В текущем отрезке перед числом может находиться
                #строковая часть, т.е. набор любых нечисловых символов.
                #Её левая граница - индекс начала отрезка,
                #а правая - индекс начала числа во всей ячейке.
                str_value = cell[cur_start_index:num_min_index]

                #Добавляем непустую или пустую строковую часть в конечный список.
                #Добавление пустой строки нужно для того, чтобы элементы одинаковых
                #позиций всех списков, полученных дроблением каждой ячейки определённого
                #сортируемого столбца, принадлежали одному и тому же типу данных.
                #Если этого не делать, то в списках, служащих правилом сортировки
                #данного столбца, на место пустой строки будет смещаться число из текущего
                #отрезка, а далее при сортировке пойдут попытки сравнить такие сползшие числа
                #с непустым строковым компонентом соответствующего предыдущего отрезка.
                sort_rule.append(str_value)

                #Добавляем в конечный список найденное число.
                #Оно будет расположено строго после
                #непустой или пустой строковой части.
                sort_rule.append(num_value)

                #Левая граница следующего отрезка будет
                #равна индексу конца числа, отмерянному
                #относительно начала всей ячейки.
                next_start_index = num_max_index

                #Левая граница гипотетического следующего считывания
                #ячейки совпадает с количеством символов этой ячейки.
                #Это означает, что следующего отрезка не будет, а
                #текущий вызов функции является самым глубоким.
                #Накопленный список возвращается предпоследнему вызову.
                if next_start_index == len(cell):
                        return sort_rule

                #Рекурсивно запускаем функцию дробления ячейки уже с новыми значениями
                #накопленного списка и левой границы отрезка в качестве аргументов.
                #Поэтапно протаскиваем список с окончательным вариантом правила
                #сортировки столбца из самого глубокого вызова функции в самый первый.
                else:
                        return cell_split(cell, sort_rule, cur_start_index=next_start_index)

        #Этот блок кода сработает либо, если в ячейке в принципе нет чисел,
        #либо если обрабатывается последний отрезок, и в нём не оказалось чисел.
        #Добавляем найденный последний (или единственный) строковый участок в список-правило.
        #Если засчёт этого строкового участка список будет выпирать по отношению к
        #другим спискам данного столбца, то ошибки сравнения разных типов данных не будет.
        #Поэтому искусственно выравнивать длины списков не нужно.
        else:
                str_value = cell[cur_start_index:]
                sort_rule.append(str_value)

                #В зависимости от того, вызывалась ли функция рекурсивно,
                #или нет, накопленный список будет возвращён либо
                #в предпоследний вызов этой функции, либо вовне.
                return sort_rule

####################################################################################################

import os
import re

src_dir_path = input('Путь к папке с исходными файлами: ')
trg_dir_path = input('Путь к папке для конечных файлов: ')
col_numbers = input('''Номер одного или номера нескольких определяющих сортировку столбцов (через пробел)
(игнорирование ввода ==> сортировка по всем столбцам): ''').split()
num_of_headers = int(input('''Количество не считываемых строк в начале файла
(хэдер, шапка таблицы и т.д.) [0|1|2|(...)]: '''))

src_file_names = os.listdir(src_dir_path)
for src_file_name in src_file_names:
        with open(os.path.join(src_dir_path, src_file_name)) as src_file_opened:

                #Формирование списка хэдеров.
                #Курсор смещается к началу основной части таблицы.
                headers = [src_file_opened.readline() for header_index in range(num_of_headers)]

                #Основная часть таблицы преобразуется в двумерный массив.
                src_table = [line.split('\t') for line in src_file_opened]

                #Пользователь не указал количество задающих сортировку столбцов.
                #Тогда сделаем таковыми все столбцы таблицы.
                if col_numbers == []:
                        col_numbers = range(len(src_table[0]) + 1)[1:]

                #Сортировка.
                src_table.sort(key = lambda row: [cell_split(row[int(col_number) - 1], []) for col_number in col_numbers])

                trg_file_name = src_file_name.split('.')[0] + '_' + 'srtd' + '.txt'
                with open(os.path.join(trg_dir_path, trg_file_name), 'w') as trg_file_opened:
                        for header in headers:
                                trg_file_opened.write(header)
                        for row in src_table:
                                if str(row[-1]).find('\n') == -1:
                                        row[-1] = str(row[-1]) + '\n'
                                trg_file_opened.write('\t'.join([str(cell) for cell in row]))
